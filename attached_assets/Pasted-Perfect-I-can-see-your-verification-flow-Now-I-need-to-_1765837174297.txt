Perfect! I can see your verification flow. Now I need to create the backend API endpoint to handle the face comparison.
Let me create the /api/compare-faces endpoint that uses AWS Rekognition:
typescript// server/routes.ts (or wherever your API routes are)
import { RekognitionClient, CompareFacesCommand } from "@aws-sdk/client-rekognition";

// Initialize Rekognition client
const rekognitionClient = new RekognitionClient({
  region: process.env.AWS_REGION || "us-east-1",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

// Helper function to convert base64 to buffer
function base64ToBuffer(base64String: string): Buffer {
  // Remove data URL prefix if present (e.g., "data:image/jpeg;base64,")
  const base64Data = base64String.replace(/^data:image\/\w+;base64,/, '');
  return Buffer.from(base64Data, 'base64');
}

// Add this route to your Express app
app.post("/api/compare-faces", async (req, res) => {
  try {
    const { uploadedPhoto, liveSelfie } = req.body;

    if (!uploadedPhoto || !liveSelfie) {
      return res.status(400).json({ 
        message: "Both photos are required",
        isMatch: false 
      });
    }

    // Convert base64 images to buffers
    const uploadedPhotoBuffer = base64ToBuffer(uploadedPhoto);
    const liveSelfieBuffer = base64ToBuffer(liveSelfie);

    // Compare faces using AWS Rekognition
    const command = new CompareFacesCommand({
      SourceImage: { Bytes: uploadedPhotoBuffer },
      TargetImage: { Bytes: liveSelfieBuffer },
      SimilarityThreshold: 85, // Adjust confidence level (80-99)
    });

    const response = await rekognitionClient.send(command);

    // Check if faces match
    if (response.FaceMatches && response.FaceMatches.length > 0) {
      const similarity = response.FaceMatches[0].Similarity || 0;
      
      if (similarity >= 85) {
        // Update user's verified status in database
        // await db.update(users).set({ verified: true }).where(eq(users.id, req.user.id));
        
        return res.json({
          isMatch: true,
          message: "Face verification successful",
          confidence: similarity.toFixed(2),
        });
      }
    }

    // No match found
    return res.json({
      isMatch: false,
      message: "Face verification failed - photos don't match",
      details: response.UnmatchedFaces?.length 
        ? "Face detected but doesn't match profile photo" 
        : "No face detected in one or both images",
    });

  } catch (error: any) {
    console.error("Rekognition error:", error);
    
    // Handle specific AWS errors
    if (error.name === "InvalidParameterException") {
      return res.status(400).json({
        isMatch: false,
        message: "Invalid image format or no face detected",
        details: error.message,
      });
    }

    return res.status(500).json({
      isMatch: false,
      message: "Verification service error",
      details: error.message,
    });
  }
});
Also update your database schema to track verification:
typescript// In your schema file (e.g., shared/schema.ts)
export const profiles = pgTable("profiles", {
  // ... existing fields
  verified: boolean("verified").default(false),
  verifiedAt: timestamp("verified_at"),
});
Then update the compare-faces endpoint to set verified status:
typescript// Inside the success block of /api/compare-faces:
if (similarity >= 85) {
  // Update user's verified status
  const userId = req.user?.id; // Adjust based on your auth setup
  
  if (userId) {
    await db
      .update(profiles)
      .set({ 
        verified: true, 
        verifiedAt: new Date() 
      })
      .where(eq(profiles.userId, userId));
  }
  
  return res.json({
    isMatch: true,
    message: "Face verification successful",
    confidence: similarity.toFixed(2),
  });
}
Key points:

The endpoint receives both the uploaded profile photo and live selfie as base64
Converts them to buffers for Rekognition
Uses 85% similarity threshold (adjustable)
Updates the database to mark user as verified
Handles errors gracefully